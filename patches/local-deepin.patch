--- local.orig	2022-01-11 02:53:58.442624700 +0800
+++ local	2022-01-09 05:20:25.466859800 +0800
@@ -194,6 +194,9 @@
 	fi
 
 	local_premount
+	
+###DO#NOT#DELETE#THIS#MARKER###
+if [ -z "$KLOOP" ] && [ -z "$SQUASHFS" ] && [ -z "$UPPERDIR" ] && [ -z "$QEMUNBD" ] ; then
 
     if [ "${readonly?}" = "y" ] && \
        [ -z "$LOOP" ]; then
@@ -258,8 +261,380 @@
 		if [ -d "$rootmnt/host" ]; then
 			mount -o move /host "$rootmnt/host"
 		fi
+	fi
+fi
+if [ -n "$KLOOP" ]; then
+
+	### reset the value of the root variable 
+	HOSTDEV="${ROOT}"
+	NEWROOT="${rootmnt}"
+	[ -n "$KROOT" ] && ROOT="$KROOT"
+	[ -n "$KROOT" ] || ROOT="/dev/loop0"
+	export ROOT
+	realroot="$ROOT"
+
+	###  auto probe the fs-type of the partition in which vhd-file live and mount it  /host 
+	mkdir -p /host
+	if [ -e ${NEWROOT}${KLOOP} ]; then
+		mount --move $NEWROOT /host
+	else	
+		if [ -z "$HOSTFSTYPE" ]; then
+			HOSTFSTYPE="$(blkid -s TYPE -o value "${HOSTDEV}")"
+			#[ -z "$HOSTFSTYPE"  -o "${HOSTFSTYPE}" = "ntfs" ] && HOSTFSTYPE="ntfs-3g"
+		fi
+		case ${HOSTFSTYPE} in
+			ntfs)
+				if [ $(grep "ntfs3" /proc/filesystems | cut -f 2) ] || [ $(find /lib/modules/ -name "ntfs3.ko") ]; then
+					modprobe ntfs3 >/dev/null 2>&1
+					mount -t ntfs3 -o rw ${HOSTDEV} /host
+					mountroot_status="$?"
+				elif [ $(grep ntfs /proc/filesystems | cut -f 2) ] || [ $(find /lib/modules/ -name "ntfs.ko") ]; then
+					modprobe ntfs >/dev/null 2>&1
+					mount -t ntfs -o rw ${HOSTDEV} /host
+					mountroot_status="$?"
+				elif [ -a /usr/bin/ntfs-3g ]; then
+					ntfs-3g -o rw ${HOSTDEV} /host
+					mountroot_status="$?"
+				fi
+				if [ "$mountroot_status" != 0 ]; then
+						panic "
+Could not mount the partition ${ROOT}.
+This could also happen if the file system is not clean because of an operating
+system crash, an interrupted boot process, an improper shutdown, or unplugging
+of a removable device without first unmounting or ejecting it.  To fix this,
+simply reboot into Windows, let it fully start, log in, run 'chkdsk /r', then
+gracefully shut down and reboot back into Windows. After this you should be
+able to reboot again and resume the installation.
+(filesystem = ${FSTYPE}, error code = $mountroot_status)
+"
+				fi
+				;;
+			exfat)
+				if [ $(grep "exfat" /proc/filesystems | cut -f 2) ] || [ $(find /lib/modules/ -name "exfat.ko") ]; then
+					modprobe exfat >/dev/null 2>&1
+					mount -t exfat -o rw ${HOSTDEV} /host
+					mountroot_status="$?"
+				elif [ -a /usr/bin/mount.exfat-fuse ]; then
+					mount.exfat-fuse ${HOSTDEV} /host
+					mountroot_status="$?"
+				fi
+				if [ "$mountroot_status" != 0 ]; then
+						panic "
+Could not mount the partition ${ROOT}.
+This could also happen if the file system is not clean because of an operating
+system crash, an interrupted boot process, an improper shutdown, or unplugging
+of a removable device without first unmounting or ejecting it.  To fix this,
+simply reboot into Windows, let it fully start, log in, run 'chkdsk /r', then
+gracefully shut down and reboot back into Windows. After this you should be
+able to reboot again and resume the installation.
+(filesystem = ${FSTYPE}, error code = $mountroot_status)
+"
+				fi
+				;;
+			*)
+				modprobe ${HOSTFSTYPE} >/dev/null 2>&1
+				mount -t ${HOSTFSTYPE} -o rw ${HOSTDEV} /host
+				;;
+		esac
+	fi
+	
+	### mount the vhd-file on a loop-device 
+	if [ "${KLOOP#/}" !=  "${KLOOP}" ]; then
+		modprobe  loop  
+		kpartx -av /host${KLOOP}
+		[ -e "$realroot" ] || sleep 3
+	fi
 
+	### probe lvm on vhd-file
+	if [ -n "$KLVM" ];  then
+		modprobe dm-mod
+		vgscan
+		vgchange  -ay  ${KLVM}
+		[ -e "$realroot" ] ||  sleep 3
+	fi 
+
+	if [ "${readonly}" = "y" ] ; then
+		roflag="-r"
+	else
+		roflag="-w"
+	fi
+	 
+	### mount the realroot / in vhd-file on $NEWROOT 
+	if [ -z "${KLOOPFSTYPE}" ]; then
+		KLOOPFSTYPE="$(blkid -s TYPE -o value "$realroot")"
+		[ -z "${KLOOPFSTYPE}" ] && KLOOPFSTYPE="ext4"
+	fi
+	[ -e "$realroot" ] || sleep 3
+	mount    ${roflag} -t "${KLOOPFSTYPE}"  $realroot $NEWROOT
+	
+	### mount /host in initrd to /host of the realrootfs
+	[ -d  ${NEWROOT}/host ] || mkdir -p ${NEWROOT}/host 
+	mount --move /host   ${NEWROOT}/host
+fi
+
+if  [ -n "$QEMUNBD" ] ; then
+
+	### reset the value of the root variable 
+	HOSTDEV="${ROOT}"
+	NEWROOT="${rootmnt}"
+	[ -n "$KROOT" ] && ROOT="$KROOT"
+	[ -n "$KROOT" ] || ROOT="/dev/loop0"
+	export ROOT
+	realroot="$ROOT"
+
+	###  auto probe the fs-type of the partition in which vhd-file live and mount it  /host 
+	mkdir -p /host
+	if [ -e $NEWROOT$QEMUNBD ]; then
+		mount --move $NEWROOT /host
+	else	
+		if [ -z "$HOSTFSTYPE" ]; then
+			HOSTFSTYPE="$(blkid -s TYPE -o value "${HOSTDEV}")"
+		fi
+		case ${HOSTFSTYPE} in
+			ntfs)
+				if [ $(grep "ntfs3" /proc/filesystems | cut -f 2) ] || [ $(find /lib/modules/ -name "ntfs3.ko") ]; then
+					modprobe ntfs3 >/dev/null 2>&1
+					mount -t ntfs3 -o rw ${HOSTDEV} /host
+					mountroot_status="$?"
+				elif [ $(grep ntfs /proc/filesystems | cut -f 2) ] || [ $(find /lib/modules/ -name "ntfs.ko") ]; then
+					modprobe ntfs >/dev/null 2>&1
+					mount -t ntfs -o rw ${HOSTDEV} /host
+					mountroot_status="$?"
+				elif [ -a /usr/bin/ntfs-3g ]; then
+					ntfs-3g -o rw ${HOSTDEV} /host
+					mountroot_status="$?"
+				fi
+				if [ "$mountroot_status" != 0 ]; then
+						panic "
+Could not mount the partition ${ROOT}.
+This could also happen if the file system is not clean because of an operating
+system crash, an interrupted boot process, an improper shutdown, or unplugging
+of a removable device without first unmounting or ejecting it.  To fix this,
+simply reboot into Windows, let it fully start, log in, run 'chkdsk /r', then
+gracefully shut down and reboot back into Windows. After this you should be
+able to reboot again and resume the installation.
+(filesystem = ${FSTYPE}, error code = $mountroot_status)
+"
+				fi
+				;;
+			exfat)
+				if [ $(grep "exfat" /proc/filesystems | cut -f 2) ] || [ $(find /lib/modules/ -name "exfat.ko") ]; then
+					modprobe exfat >/dev/null 2>&1
+					mount -t exfat -o rw ${HOSTDEV} /host
+					mountroot_status="$?"
+				elif [ -a /usr/bin/mount.exfat-fuse ]; then
+					mount.exfat-fuse ${HOSTDEV} /host
+					mountroot_status="$?"
+				fi
+				if [ "$mountroot_status" != 0 ]; then
+						panic "
+Could not mount the partition ${ROOT}.
+This could also happen if the file system is not clean because of an operating
+system crash, an interrupted boot process, an improper shutdown, or unplugging
+of a removable device without first unmounting or ejecting it.  To fix this,
+simply reboot into Windows, let it fully start, log in, run 'chkdsk /r', then
+gracefully shut down and reboot back into Windows. After this you should be
+able to reboot again and resume the installation.
+(filesystem = ${FSTYPE}, error code = $mountroot_status)
+"
+				fi
+				;;
+			*)
+				modprobe ${HOSTFSTYPE} >/dev/null 2>&1
+				mount -t ${HOSTFSTYPE} -o rw ${HOSTDEV} /host
+				;;
+		esac
+	fi
+	
+	### mount the vhd-file on a loop-device 
+	if [ "${QEMUNBD#/}" !=  "${QEMUNBD}" ]; then       	
+		modprobe  nbd  
+		modprobe  loop
+		[ -e  /dev/nbd0 ] || sleep 3 
+		qemu-nbd  -c /dev/nbd0  /host${QEMUNBD}
+		kpartx -av /dev/nbd0
+		[ -e "$realroot" ] || sleep 3
+	fi
+
+	if [ "${readonly}" = "y" ] ; then
+		roflag="-r"
+	else
+		roflag="-w"
+	fi
+	 
+	### mount the realroot / in vhd-file on $NEWROOT 
+	if [ -z "${KLOOPFSTYPE}" ]; then
+		KLOOPFSTYPE="$(blkid -s TYPE -o value "$realroot")"
+		[ -z "${KLOOPFSTYPE}" ] && KLOOPFSTYPE="ext4"
+	fi
+	[ -e "$realroot" ] || sleep 3
+	mount    ${roflag} -t "${KLOOPFSTYPE}"  $realroot $NEWROOT
+	
+	### mount /host in initrd to /host of the realrootfs
+	[ -d  ${NEWROOT}/host ] || mkdir -p ${NEWROOT}/host 
+	mount --move /host   ${NEWROOT}/host
+fi
+
+if [ -n "$UPPERDIR" ] && [ -n "$WORKDIR" ];  then
+
+	### reset the value of the root variable 
+	HOSTDEV="${ROOT}"
+	NEWROOT="${rootmnt}"
+	
+	###  auto probe the fs-type of the partition in which vhd-file live and mount it  /host 
+	mkdir -p /host
+	if [ -e ${NEWROOT}${UPPERDIR} ]; then
+		mount --move $NEWROOT /host
+	else	
+		if [ -z "$HOSTFSTYPE" ]; then
+			HOSTFSTYPE="$(blkid -s TYPE -o value "${HOSTDEV}")"
+		fi
+		case ${HOSTFSTYPE} in
+			ntfs)
+				if [ $(grep "ntfs3" /proc/filesystems | cut -f 2) ] || [ $(find /lib/modules/ -name "ntfs3.ko") ]; then
+					modprobe ntfs3 >/dev/null 2>&1
+					mount -t ntfs3 -o rw ${HOSTDEV} /host
+					mountroot_status="$?"
+				elif [ $(grep ntfs /proc/filesystems | cut -f 2) ] || [ $(find /lib/modules/ -name "ntfs.ko") ]; then
+					modprobe ntfs >/dev/null 2>&1
+					mount -t ntfs -o rw ${HOSTDEV} /host
+					mountroot_status="$?"
+				elif [ -a /usr/bin/ntfs-3g ]; then
+					ntfs-3g -o rw ${HOSTDEV} /host
+					mountroot_status="$?"
+				fi
+				if [ "$mountroot_status" != 0 ]; then
+						panic "
+Could not mount the partition ${ROOT}.
+This could also happen if the file system is not clean because of an operating
+system crash, an interrupted boot process, an improper shutdown, or unplugging
+of a removable device without first unmounting or ejecting it.  To fix this,
+simply reboot into Windows, let it fully start, log in, run 'chkdsk /r', then
+gracefully shut down and reboot back into Windows. After this you should be
+able to reboot again and resume the installation.
+(filesystem = ${FSTYPE}, error code = $mountroot_status)
+"
+				fi
+				;;
+			exfat)
+				if [ $(grep "exfat" /proc/filesystems | cut -f 2) ] || [ $(find /lib/modules/ -name "exfat.ko") ]; then
+					modprobe exfat >/dev/null 2>&1
+					mount -t exfat -o rw ${HOSTDEV} /host
+					mountroot_status="$?"
+				elif [ -a /usr/bin/mount.exfat-fuse ]; then
+					mount.exfat-fuse ${HOSTDEV} /host
+					mountroot_status="$?"
+				fi
+				if [ "$mountroot_status" != 0 ]; then
+						panic "
+Could not mount the partition ${ROOT}.
+This could also happen if the file system is not clean because of an operating
+system crash, an interrupted boot process, an improper shutdown, or unplugging
+of a removable device without first unmounting or ejecting it.  To fix this,
+simply reboot into Windows, let it fully start, log in, run 'chkdsk /r', then
+gracefully shut down and reboot back into Windows. After this you should be
+able to reboot again and resume the installation.
+(filesystem = ${FSTYPE}, error code = $mountroot_status)
+"
+				fi
+				;;
+			*)
+				modprobe ${HOSTFSTYPE} >/dev/null 2>&1
+				mount -t ${HOSTFSTYPE} -o rw ${HOSTDEV} /host
+				;;
+		esac
+	fi
+		
+	###try to boot from dir
+	modprobe overlay
+	mkdir  /run/lowerdir 
+	mount  -t overlay overlay -o lowerdir=/run/lowerdir,upperdir=/host$UPPERDIR,workdir=/host$WORKDIR  $NEWROOT
+
+	### mount /host in initrd to /host of the realrootfs
+	[ -d  ${NEWROOT}/host ] || mkdir -p ${NEWROOT}/host 
+	mount --move /host   ${NEWROOT}/host
+fi	
+
+if [ -n "$SQUASHFS" ];  then
+
+	### reset the value of the root variable 
+	HOSTDEV="${ROOT}"
+	NEWROOT="${rootmnt}"
+	
+	###  auto probe the fs-type of the partition in which vhd-file live and mount it  /host 
+	mkdir -p /host
+	if [ -e ${NEWROOT}${SQUASHFS} ]; then
+		mount --move $NEWROOT /host
+	else	
+		if [ -z "$HOSTFSTYPE" ]; then
+			HOSTFSTYPE="$(blkid -s TYPE -o value "${HOSTDEV}")"
+		fi
+		case ${HOSTFSTYPE} in
+			ntfs)
+				if [ $(grep "ntfs3" /proc/filesystems | cut -f 2) ] || [ $(find /lib/modules/ -name "ntfs3.ko") ]; then
+					modprobe ntfs3 >/dev/null 2>&1
+					mount -t ntfs3 -o rw ${HOSTDEV} /host
+					mountroot_status="$?"
+				elif [ $(grep ntfs /proc/filesystems | cut -f 2) ] || [ $(find /lib/modules/ -name "ntfs.ko") ]; then
+					modprobe ntfs >/dev/null 2>&1
+					mount -t ntfs -o rw ${HOSTDEV} /host
+					mountroot_status="$?"
+				elif [ -a /usr/bin/ntfs-3g ]; then
+					ntfs-3g -o rw ${HOSTDEV} /host
+					mountroot_status="$?"
+				fi
+				if [ "$mountroot_status" != 0 ]; then
+						panic "
+Could not mount the partition ${ROOT}.
+This could also happen if the file system is not clean because of an operating
+system crash, an interrupted boot process, an improper shutdown, or unplugging
+of a removable device without first unmounting or ejecting it.  To fix this,
+simply reboot into Windows, let it fully start, log in, run 'chkdsk /r', then
+gracefully shut down and reboot back into Windows. After this you should be
+able to reboot again and resume the installation.
+(filesystem = ${FSTYPE}, error code = $mountroot_status)
+"
+				fi
+				;;
+			exfat)
+				if [ $(grep "exfat" /proc/filesystems | cut -f 2) ] || [ $(find /lib/modules/ -name "exfat.ko") ]; then
+					modprobe exfat >/dev/null 2>&1
+					mount -t exfat -o rw ${HOSTDEV} /host
+					mountroot_status="$?"
+				elif [ -a /usr/bin/mount.exfat-fuse ]; then
+					mount.exfat-fuse ${HOSTDEV} /host
+					mountroot_status="$?"
+				fi
+				if [ "$mountroot_status" != 0 ]; then
+						panic "
+Could not mount the partition ${ROOT}.
+This could also happen if the file system is not clean because of an operating
+system crash, an interrupted boot process, an improper shutdown, or unplugging
+of a removable device without first unmounting or ejecting it.  To fix this,
+simply reboot into Windows, let it fully start, log in, run 'chkdsk /r', then
+gracefully shut down and reboot back into Windows. After this you should be
+able to reboot again and resume the installation.
+(filesystem = ${FSTYPE}, error code = $mountroot_status)
+"
+				fi
+				;;
+			*)
+				modprobe ${HOSTFSTYPE} >/dev/null 2>&1
+				mount -t ${HOSTFSTYPE} -o rw ${HOSTDEV} /host
+				;;
+		esac
 	fi
+	
+	###try to boot from squashfs
+	modprobe overlay
+	mkdir  -p /run/lowerdir /run/upperdir  /run/workdir
+	mount  /host$SQUASHFS  /run/lowerdir
+	mount  -t overlay overlay -o lowerdir=/run/lowerdir,upperdir=/run/upperdir,workdir=/run/workdir    $NEWROOT
+
+	### mount /host in initrd to /host of the realrootfs
+	[ -d  ${NEWROOT}/host ] || mkdir -p ${NEWROOT}/host 
+	mount --move /host   ${NEWROOT}/host
+fi	
 }
 
 local_mount_fs()
